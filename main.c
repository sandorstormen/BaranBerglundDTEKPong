#include <pic32mx.h>
#include <stdint.h>
#include <stdlib.h>
#include "sprites.h"

#define DISPLAY_VDD PORTFbits.RF6
#define DISPLAY_VBATT PORTFbits.RF5
#define DISPLAY_COMMAND_DATA PORTFbits.RF4
#define DISPLAY_RESET PORTGbits.RG9


#define DISPLAY_VDD_PORT PORTF // Uno32 pin 38
#define DISPLAY_VDD_MASK 0x40
#define DISPLAY_VBATT_PORT PORTF // Uno32 pin 40
#define DISPLAY_VBATT_MASK 0x20
#define DISPLAY_COMMAND_DATA_PORT PORTF // Uno32 pin 39
#define DISPLAY_COMMAND_DATA_MASK 0x10
#define DISPLAY_RESET_PORT PORTG // Uno32 pin 10 JP4
#define DISPLAY_RESET_MASK 0x200

/*	The display has a D/C pin (display or command select) that is used to determine whether bytes sent to the display
**	are interpreted as commands or as display data. The D/C pin is set high for display buffer access and low for
**	command access.
*/

const uint8_t blank_screen [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void delay(int cyc) {
	int i;
	for(i = cyc; i > 0; i--);
}

uint8_t spi_send_recv(uint8_t data) {
	while(!(SPI2STAT & 0x08));
	SPI2BUF = data;
	while(!(SPI2STAT & 0x01));
	return SPI2BUF;
}


void display_init() {
	DISPLAY_COMMAND_DATA_PORT &= ~DISPLAY_COMMAND_DATA_MASK; // Clear the command port
	delay(10);
	DISPLAY_VDD_PORT &= ~DISPLAY_VDD_MASK; // Put the power on for the display and wait for it to power on
	delay(1000000);
	
	spi_send_recv(0xAE);	// Display off command
	DISPLAY_RESET_PORT &= ~DISPLAY_RESET_MASK;	// Bring reset low 
	delay(10);
	DISPLAY_RESET_PORT |= DISPLAY_RESET_MASK;	// Bring rest high
	delay(10);
	
	spi_send_recv(0x8D);	// Send the Set Charge Pump from P 3/6 https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf
	spi_send_recv(0x14);
	
	spi_send_recv(0xD9);	// Set Pre-Charge Period command from P 32/59 https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf 
	spi_send_recv(0xF1);
	
	DISPLAY_VBATT_PORT &= ~DISPLAY_VBATT_MASK;  // Turn on VCC and wait 100ms
	delay(10000000);
	// Send the commands to invert the display. This puts the display origin in the upper left corner.
	spi_send_recv(0xA1);	//remap columns
	spi_send_recv(0xC8);	//remap rows
	// Send the commands to select sequential COM configuration. This makes the display memory non-interleaved.
	spi_send_recv(0xDA); //set COM configuration command
	spi_send_recv(0x20); //sequential COM, left/right remap enabled
	
	spi_send_recv(0x81); // Set contrast command
	spi_send_recv(0xFF); // Hex for 255
	
	spi_send_recv(0xAF); // Send Display On command
}

void port_init() {
	/* Set up peripheral bus clock */
	OSCCON &= ~0x180000;
	OSCCON |= 0x080000;
	
	/* Set up output pins */
	AD1PCFG = 0xFFFF;
	ODCE = 0x0;
	TRISECLR = 0xFF;
	PORTE = 0x0;
	
	/* Output pins for display signals */
	PORTF = 0xFFFF;
	PORTG = (1 << 9);
	ODCF = 0x0;
	ODCG = 0x0;
	TRISFCLR = 0x70;
	TRISGCLR = 0x200;
	
	/* Set up input pins */
	TRISDSET = (1 << 8);
	TRISFSET = (1 << 1);
	
	/* Set up SPI as master */
	SPI2CON = 0;
	SPI2BRG = 4;
	
	/* Clear SPIROV*/
	SPI2STATCLR &= ~0x40;
	/* Set CKP = 1, MSTEN = 1; */
    SPI2CON |= 0x60;
	
	/* Turn on SPI */
	SPI2CONSET = 0x8000;
	
	// Timer setup
	T2CON = 0x8058; // bit 15 = 1 timer is enabled | bit 6-4 = 101 1:32 scaling | bit 3 = 1 32-bit mode | bit 1 = 0 internal clock
	PR2 = 250000; // 1/(80*10^6)/32/250000 = 1/10
}

void display_image(const uint8_t data[]) {
	int i, j;
	spi_send_recv(0x20); // Set adressing mode
	spi_send_recv(0x2); // Page adressing mode
	for(i = 0; i < 4; i++) {
		DISPLAY_COMMAND_DATA_PORT &= ~DISPLAY_COMMAND_DATA_MASK;
		spi_send_recv(0xB0 + i);
		//spi_send_recv(0x22);
		//spi_send_recv(i);
		
		//spi_send_recv(x & 0xF);
		//spi_send_recv(0x10 | ((x >> 4) & 0xF));
		
		DISPLAY_COMMAND_DATA_PORT |= DISPLAY_COMMAND_DATA_MASK;
		
		for(j = 0; j < 128; j++)
			spi_send_recv(data[i*128 + j]);
		DISPLAY_COMMAND_DATA_PORT &= ~DISPLAY_COMMAND_DATA_MASK;
	}
}

void display_clear() {
	int i, j;
	spi_send_recv(0x20); // Set adressing mode
	spi_send_recv(0x2); // Page adressing mode
	for(i = 0; i < 8; i++) {
		DISPLAY_COMMAND_DATA_PORT &= ~DISPLAY_COMMAND_DATA_MASK;
		
		spi_send_recv(0xB0 + i);
		//spi_send_recv(i);
		
		//spi_send_recv(x & 0xF);
		//spi_send_recv(0x10 | ((x >> 4) & 0xF));
		
		DISPLAY_COMMAND_DATA_PORT |= DISPLAY_COMMAND_DATA_MASK;
		
		for(j = 0; j < 128; j++) {
			spi_send_recv((uint8_t)0x00);
		}
	}
}

void moveSprite(int shftX, int shftY, uint8_t *data) {
	int i;
	for(i = 0; i < 4096; i++){
		if ( shftX < 0) {
			data[i] = data[i] >> shftX;
		}
		if ( shftX > 0) {
			data[i] = data[i] << shftX;
		}
		if ( shftY < 0) {
			data[i] = data[i] >> shftY;
		}
		if ( shftY > 0) {
			data[i] = data[i] << shftY;
		}
	}
}
void main_menu_init();
void main_menu_update();
void main_menu_update();

struct Ball currentBall;
struct Paddle paddle_l, paddle_r;
void game_init(){
	currentBall.x= 64;
	currentBall.y= 4;
};
void game_update();

uint8_t* make_screen_game(uint8_t* retArray, Ball ball, Paddle l_paddle, Paddle r_paddle) {
	int i, j;
	for(i = 0; i < 4096; i++) {
	retArray[i] = blank_screen[i];
	}
	for(i = 0; i < 4; i++) {
		for(j = 0; j < 128; j++) {
			if(ball.x <= j && ball.x + 12 >= j && ball.y <= i && ball.y + 9 >= i) {
				retArray[i*128 + j] |= ball_sprite[i][j];
			}
		}
	}
	return;
}
void game_draw(){
	if(IFS(0) & 0x10) {
		IFS(0) &= ~0x10;
		display_clear();
		//display_image(make_screen_game(currentBall, paddle_l, paddle_r));	
	}
}

int main() {
	port_init();
	display_init();
	game_init();
	display_clear();
	uint8_t* display_array[4096];
	while(1) {
		//game_draw();
		make_screen_game(display_array, currentBall, paddle_l, paddle_r);
		display_image(display_array);
	}
	
	for(;;);
	return 0;
}
